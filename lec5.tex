\documentclass{beamer}

\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{purple}{RGB}{153, 0, 153}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}}


% Python environment
\lstnewenvironment{code}[1][]
{
%\begin{small}
\pythonstyle
\lstset{#1}
%\end{small}
}
{}


\begin{document}

% Lists and dictionaries theory. For loops and lists. Quiz on content so far. 



\begin{frame}
\frametitle{CS24420 \& MA25220 \& MT25220 \& MX35220 \& CSM0120}

\begin{center}
\begin{huge}
Lecture 5: Tuples, Dictionaries and Sets
\end{huge}
\bigskip

Amanda Clare (afc@aber.ac.uk)\\
Sam Nicholls (msn@aber.ac.uk)

\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Tuples}
    A \texttt{tuple} is a \textbf{finite} sequence of \textbf{ordered} items.\\
    \texttt{Tuple}s store a \textbf{fixed} number of \textbf{immutable} elements.\\
    \texttt{Tuple}s can serve as a container for grouping related variables.
    \\For example:

    \begin{itemize}
        \item A co-ordinate such as (x, y), or (latitude, longitude)
        \item A colour defined in RGB space, like {\color{purple}(153, 0, 153)}
        \item Grouped information such as (firstname, surname, age)
    \end{itemize}

\vskip 0.3cm
    \texttt{Tuple}s look like \texttt{list}s, but are enclosed in parentheses:
\begin{code}
>>> aber = (52.4153, 4.0829)
>>> sam = ("Sam", "Nicholls", 25)
\end{code}
Although valid, it's considered bad practice to mix types in a \texttt{list}.
\texttt{Tuple}s provide a more natural data structure for mixed types.
\end{frame}


\begin{frame}[fragile]
\frametitle{Handling Tuples}
    Like \texttt{list}s, \texttt{tuple} elements can be indexed, sliced and counted:
\begin{code}
>>> sam = ("Sam", "Nicholls", 25)
>>> sam[0]
'Sam'
>>> sam[1:3]
('Nicholls', 25)
>>> len(sam)
3
\end{code}

\vskip 0.3cm
Unlike \texttt{list}s, elements of \texttt{tuple}s are \textbf{immutable}:
\begin{code}
>>> sam[2] = 26
TypeError: 'tuple' object does not support
           item assignment
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{Tuples as Containers}
    \texttt{Tuple}s may contain other data structures, including \texttt{tuple}s!

\begin{code}
>>> sam = ("Sam", "Nicholls", ["cs244"])
>>> alice = ("Alice", "Wunderland", ["en207"])
>>> students = (sam, alice)
>>> students
(
    ('Sam', 'Nicholls', ['cs244']),
    ('Alice', 'Wunderland', ['en207'])
)
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{Packing and Unpacking Tuples}
    \texttt{Tuple}s can actually be constructed without the parentheses...\\
    A \texttt{tuple} can be \textit{packed} by enumerating its elements
and delimiting them with a comma:

\begin{code}
>>> sam = "Sam", "Nicholls", 25
>>> sam
('Sam', 'Nicholls', 25)
\end{code}

\vskip 0.3cm
Conversely, one may \textit{unpack} each of the elements of a \texttt{tuple}
    into suitably named, \textbf{ordered} variables:
\begin{code}
>>> firstname, surname, age = sam
>>> firstname
'Sam'
\end{code}
Unpacking requires the same number of variables on the left as there
    are elements in the \texttt{tuple} on the right.
\end{frame}

sets
list comprehensions
string formatting
order of keys is not guaranteed!
% list comprehensions? Generators and iterators? 

\begin{frame}[fragile]
\frametitle{Dictionaries}
A dictionary is a data structure where you can store
keys and values.

For example:
\begin{itemize}
\item A birthday book: look up the birthday (value) for the
name of a person (key)
\item A price list: look up the price (value) of a product
using its barcode (key)
\item Coordinates of a gene: look up the location (value)
of a gene given its systematic identifier (key)
\item Look up the capital city (value) given the name of a
country
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Creating dictionaries and adding items}
We use curly brackets to create a new dictionary:
\begin{code}
>>> phonebook = {}
\end{code}
We can add items (new key and value):
\begin{code}
>>> phonebook['John'] = 724736
\end{code}
We can update existing items (alter the value):
\begin{code}
>>> phonebook['John'] = 666666
\end{code}
We could create a new dictionary with many items:
\begin{code}
>>> ages = { "a": 34, "b":28, "c":56 }
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{Requesting data}
We can request the value that the dictionary holds for a specific
key:
\begin{code}
>>> office = { "John" : 4, "Sarah" : 5 }
>>> office["John"]
\end{code}
 What happens if a key is not present?
\begin{code}
>>> office["Jane"]
\end{code}
 What happens if a key is used more than once?
\begin{code}
>>> office = { "John" : 4, "Sarah" : 5, "John" : 7 }
>>> office["John"]
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{Requesting data}
We can check if a key is present, and if so, find out the
value:
\begin{code}
student = "Jane"
if student in exam_result:
   print(exam_result[student])
else:
   print("No value found for " + student)
\end{code}
\end{frame}



\begin{frame}[fragile]
\frametitle{Getting all values out}
\begin{code}
age = { "a": 34, "b":28, "c":56 }
print(age.keys())
print(age.values())

for k in age.keys():
   print(age[k])
\end{code}
We can use .keys() to find out the keys that are in a dictionary.
We use square brackets after the dictionary name [] to find
out what value belongs to that key.
\end{frame}

\begin{frame}[fragile]
\frametitle{Simpler, more Pythonic}
\begin{code}
for k in my_dict.keys():
   print(my_dict[k])
\end{code}
can be written instead
\begin{code}
for k in my_dict:
   print(my_dict[k])
\end{code}
The .keys() is assumed if we're looping over a dictionary.
\end{frame}


\begin{frame}[fragile]
\frametitle{Checking for presence of a key}

If we're not sure if a key is present, better check:
\begin{code}
if my_key in my_dict:
   print(my_dict[my_key])
else:
   print(my_key + " is not there")
\end{code}
\end{frame}

\begin{frame}
\frametitle{Exercise on the board}
Create an empty dictionary.

\bigskip

Add the following information to that dictionary: the
name (keys) and favourite food (values) of the three
people sitting closest to you. If their names are not
unique, use their full names.

\bigskip

One of those people has recently discovered how wonderful olives
are. Update the favourite food for this person.

\bigskip

Find out whether Hannah is in the dictionary or not. If she is, report
her favourite food. If she isn't, report that she's not present.
\end{frame}



\begin{frame}[fragile]
\frametitle{Quiz (in teams)}
\end{frame}


\end{document}
