\documentclass{beamer}

\usepackage{helvet}
\renewcommand{\sfdefault}{phv}
\renewcommand{\rmdefault}{phv}

\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{upquote}
\usepackage[T1]{fontenc}


% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}}


% Python environment
\lstnewenvironment{code}[1][]
{
%\begin{small}
\pythonstyle
\lstset{#1}
%\end{small}
}
{}


\begin{document}

% Python basics theory lecture. Loops (while and for-range).
% with more recap of types, variables, if, conditions

\begin{frame}
\frametitle{CS24420 \& MA25220 \& MT25220 \& MX35220 \& CSM0120}

\begin{center}
\begin{huge}
Lecture 3: Loops (and variables and user input)
\end{huge}

\bigskip

Amanda Clare (afc@aber.ac.uk)

\end{center}
\end{frame}

% ipython 

\begin{frame}[fragile]
\frametitle{Variables}
Names for values. 

\bigskip

In Python, the values have types. So 3.4 is a float,
and "hello" is a str. 

\bigskip

The variable is just a name for a value (think
of it as a pointer to that box in memory that holds the value). 

\bigskip

Later in the code, that same variable might point to another value of
a different type entirely.

\begin{code}
x = 4
print(x)
x = "hello"
print(x)
\end{code}

\end{frame}



\begin{frame}[fragile]
\frametitle{Dynamic typing}
This is known as `dynamic typing'. Python will use the types to check
that instructions are valid. Much of the type checking can only be done
dynamically, at
run time, while the code is executing, rather than statically, before
the code is run. 
 
\bigskip

Values have types. Variables are names for values.

\bigskip

The values have strong types. We can't do: 
\begin{code}
"hello" + 4

\end{code}

because these have different types and they do not satisfy \texttt{+}.
\end{frame}

\begin{frame}[fragile]
\frametitle{Dynamic typing}
Will there be a TypeError when this code is run?

\begin{code}
x = 4
y = 8
if y < 6:
   x = "world"
z = "hello" + x
print(z)
\end{code}

\end{frame}



\begin{frame}[fragile]
\frametitle{Watch out for some type issues}
However sometimes it can look as though Python isn't strongly typed
for two main reasons: 
\begin{itemize}
\item Sometimes types are silently converted (especially to bools)
\item Some operators are overloaded to have multiple uses, especially *
\end{itemize}
So we can do \texttt{"hello" * 4}, because * is overloaded for
strings and ints, unfortunately. 

\bigskip

Remember we can also evaluate: 
\begin{itemize}
\item \texttt{True and "fish"} 
\item \texttt{"fish" and True}
\end{itemize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Variables}

Variable identifiers in Python:
\begin{itemize}
\item \texttt{use\_underscores}
\item \texttt{use\_lower\_case}
\item \texttt{notCamelCase}
\item Can't start with a number (e.g. not \texttt{2night})
\item As always in programming, try to give them meaningful names
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{while loops}
We often want to repeat things many times.
\begin{code}
while True:
   print( "Hello world" )
\end{code}
\begin{itemize}
\item A while loop needs a condition and a colon.
\item The body of the loop must be indented
\item The body will be executed while the condition is still True
\item Here the condition is very simple. It never changes, so the loop
  will loop forever.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Note about print}
\texttt{print} is one of the key parts of Python that changed between
version 2 and version 3. In Python 2, \texttt{print} is a statement:

\begin{code}
print "hello"
\end{code}

Whereas in Python 3 \texttt{print} is a function, and takes arguments in round brackets:

\begin{code}
print("hello")
\end{code}

For simple uses of \texttt{print}, we can get away with round brackets
in both Python 2 and Python 3 (Python 2 will just treat these brackets
as grouping brackets):

\begin{code}
print("hello")
\end{code}

\end{frame}


\begin{frame}[fragile]
\frametitle{while loops}
\begin{code}
x = 0
while x < 100:
   print( "Hello world " + str(x) )
   x = x + 1

print("finished the loop")
print(x)
\end{code}
\begin{itemize}
\item A while loop needs a condition and a colon.
\item The body of the loop must be indented
\item The body will be executed while the condition is still True
\item Why use str?
\item Which numbers will be printed?
\item What is the value of x at the end?
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{while loops exercise}
Write a piece of code that will initialise a variable x to 200
and then use a while loop that will print out the value of x
and decrease the value of x, stopping when x is 99.

\bigskip

Could you instead stop when x is less than the length of
the string "Python rules the world"?
\end{frame}


\begin{frame}[fragile]
\frametitle{while loops - structure}
\begin{code}
# Some code before the loop
while condition:
   # Some body of the loop
   # Note that all the body is indented
   # Usually the condition tests some variable
   # Remember to change some variable, 
   # so the condition will be different next time
   # The condition determines when to loop
# Some code that does not belong to the loop
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Conditions}
What kinds of condition can we have?

Generally want something that evaluates to {\tt True} or {\tt False}.

\begin{code}
x < y
x <= y
x >= y
x == y    # equality test uses a double equals sign!
x != y
x == 5
x < 3.5/2
x < "banana"
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{Watch out for some type issues in conditions}

We can say 
\begin{code}
while "hello":
  print("ok")
\end{code}
Python's booleans can be a little hazardous.  See \url{http://anh.cs.luc.edu/python/hands-on/3.1/handsonHtml/boolean.html}
\end{frame}


\begin{frame}[fragile]
\frametitle{Conditions}
We can use {\tt and} and {\tt or} and {\tt not}.

\begin{code}
x = "Aberystwyth"
y = 3.0/5
if len(x) < 4 and y > 7:
   print("success")

x = len("Aberystwyth") > 5
y = True
if x or y:
   print("hooray!")

x = len("Aberystwyth") > 5
if not x:
   print("not long enough")
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{range}
\texttt{range(start, stop[, step])} is a function that will generate all
numbers from \texttt{start} to \texttt{stop} but not including
\texttt{stop}, jumping by the optional \texttt{step} if it is provided.
 
\begin{code}
x = range(0, 100)
print(x)
\end{code}

In Python 2, \texttt{range} returns a list. In Python 3 \texttt{range} returns a
generator (so to view the numbers as a list, use \texttt{list(range())}).

\begin{code}
>>> range(0, 10)
range(0, 10)
>>> list( range(0, 10) )
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{code}
\end{frame}


\begin{frame}
\frametitle{\texttt{range} as a generator}
\begin{itemize}
\item \texttt{range} will generate numbers. 
\item In Python3, it will generate them on-demand (won't create them all
in memory unless an until they're needed)
\item In Python2, the whole list would be created. Use \texttt{xrange} in
  Python2 if you want the generator version.
\item In Python3, if you want to see the whole lot as a list, you need
  to convert them to a list (e.g. \texttt{list( range(2, 8) )} ). Most of the
  time you don't need to do this.
\end{itemize} 
\end{frame}




\begin{frame}[fragile]
\frametitle{range}

\begin{code}
>>> print( range(0, 100) )  # or list(range(0,100))
>>> print( range(100) )
>>> print( range(1, 100) )
\end{code}
Using a step:
\begin{code}
>>> print( range(0, 100, 5) )
\end{code}
Counting down:
\begin{code}
>>> print( range(100, 0, -1) )
\end{code}
\end{frame}

\begin{frame}
\frametitle{How could we use range to make the following?}
\begin{enumerate}
\item All odd numbers from 1 to 49
\item All multiples of 4 from 0 to 100
\item A decreasing list of odd numbers from 25 to -25
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\frametitle{for loops}
We can loop with \texttt{while} and we can also loop with \texttt{for}.
Looping with \texttt{for} is particularly useful if you know you
want to do something for each item in a list, or each item produced by
a generator (rather than while a condition is True).
\begin{code}
for x in range(2, 8):
   print("The number is: " + str(x))
\end{code}
\begin{itemize}
\item We use \texttt{for} and \texttt{in}, and a colon at the end of the line.
\item We indent the body of the for loop.
\item Each time through the loop, the variable \texttt{x} holds another of the values from
  the list/generator.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{for loops}
Here we have a for-loop with a body that is an if-statement.
\bigskip
\begin{code}
for x in range(0, 100):
   if x % 7 == 0:
      print (str(x) + " is divisible by 7")
\end{code}
\end{frame}

\begin{frame}
\frametitle{Exercises}
\begin{enumerate}
\item Write a for-loop that will print out all the even numbers
between 50 and 100.
\item Write a for-loop that will sum all the even numbers
between 50 and 100 and print the sum at the end (hint:
you'll need to start by initialising a variable to collect the
sum into).
\item Write a for-loop that will print out the leap years from
now until the year 2500. Leap years are those that are
divisible by 4, except that years that are divisible by 100
are not leap years, unless they're also divisible by 400.
\end{enumerate}
\end{frame}


\begin{frame}[fragile]
\frametitle{User input}
\begin{code}
import sys
print("Enter your name")
name = sys.stdin.readline()
print("Hello " + name + ". How are you?")
\end{code}
This includes the newline character.
\end{frame}

\begin{frame}[fragile]
\frametitle{User input}
\begin{code}
import sys

print("Enter your name")
name = sys.stdin.readline()
print("Hello " + name.strip() + ". How are you?")
\end{code}
This removes the newline character.

\texttt{s.strip()} will remove any whitespace chars from both ends of a
string \texttt{s} (whitespace is spaces, newlines, tabs).
\end{frame}

\begin{frame}[fragile]
\frametitle{input()}
There is a built-in function \texttt{input}. This:
takes a prompt as
its argument, displays the prompt, 
gets a line of input from the user,
strips the trailing newline off 
and returns the line of input, as a string.
\begin{code}
name = input("Enter your name: ")
print("Hello " + name + ". How are you?")
\end{code}

However, in Python 2, input behaved differently. It didn't just return
the string, instead it evaluated the string. So if your string was "4
+ 6" it would give you the integer 10 as a result. 
\end{frame}


\begin{frame}
\frametitle{Guess the secret number!}
An interactive game to exercise what you know about
variables, if statements, loops and input/output.
\begin{itemize}
\item Initialise a variable to hold a secret number of your
choice.
\item Prompt the user to input a guess.
\item Compare the guess to the secret number. If it's
correct, print a congratulations message and stop.
\item If it's not correct, then tell the user if the secret is
lower or higher than their guess, and prompt them to
guess again. Keep going until they've guessed
correctly (while their guess is still wrong).
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Summary}
\begin{itemize}
\item Variables
\item Dynamic typing
\item \texttt{while} loops
\item \texttt{range}
\item \texttt{for} loops
\item User input
\end{itemize}
\end{frame}

\end{document}
