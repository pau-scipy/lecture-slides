\documentclass{beamer}

\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}}


% Python environment
\lstnewenvironment{code}[1][]
{
%\begin{small}
\pythonstyle
\lstset{#1}
%\end{small}
}
{}


\begin{document}

% Theory of functions and their correspondence to maths
% functions. Return values and None. print vs
% return. Parameters. What's the point of functions. Passing functions
% as parameters.

\begin{frame}
\frametitle{CS24420 \& MA25220 \& MT25220 \& MX35220 \& CSM0120}}

\begin{center}
\begin{huge}
Lecture 9: Functions, the gory details
\end{huge}
\bigskip

Amanda Clare (afc@aber.ac.uk)

\end{center}
\end{frame}

% Guido video on type hints


\begin{frame}[fragile]
\frametitle{Functions in maths}
Assume we have 2 sets, $A$ and $B$. For example: countries and capital cities
\bigskip

We could imagine all possible pairings of elements such that one
element in the pair is from $A$ and the other is from $B$. 
\bigskip

For example, if
$A = \{France, UK, Spain\}$ and $B = \{Paris, London, Madrid\}$ then all
possible pairs are:
\begin{multline*}
\{ (France, London), (France, Paris), (France, Madrid), \\
(UK, London),
  (UK, Paris), (UK, Madrid), \\
(Spain, Paris), (Spain, London), (Spain,
  Madrid) \}
 \end{multline*}
\end{frame}


\begin{frame}[fragile]
\frametitle{Relations in maths}
The set of all possible pairs from $A$ and $B$ is known as the cartesian product of $A$
and $B$.

A subset of this (that is, some of the pairs but not necessarily all
of them) is called a \em{relation}.

For example: 
\begin{itemize} 
\item the capital cities of each country: $\{(France, Paris), (UK,
  London), (Spain, Madrid) \}$
\item popular holiday destinations: $\{ (France, Paris), (UK, Paris),
  (Spain, London) \}$
\item same number of letters in word: $\{ (France, London), (Spain,
  Paris) \}$
\item Continental flight destinations from UK: $\{ (UK, Paris), (UK, Madrid) \}$
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Functions in maths}
A function is a relation where there's a single output for
any given input. \\
A single element of $B$ for every element of $A$ in the relation.
So we can pick any input element and know that an output
exists. \\
We also know it's the only output (there's no confusion). \\
We can think of a function as a mapping from elements in $A$
to elements in $B$.

\end{frame}


\begin{frame}[fragile]
\frametitle{Which of these are functions}

Which of these relations are functions?
 
\begin{itemize} 
\item the capital cities of each country: $\{(France, Paris), (UK,
  London), (Spain, Madrid) \}$
\item popular holiday destinations: $\{ (France, Paris), (UK, Paris),
  (Spain, London) \}$
\item same number of letters in word: $\{ (France, London), (Spain,
  Paris) \}$
\item Continental flight destinations from UK: $\{ (UK, Paris), (UK, Madrid) \}$
\end{itemize}
\pause
A partial function is not defined for all elements of $A$, only some
of them. For some elements there is no output. Which of these are partial?
\end{frame}

\begin{frame}[fragile]
\frametitle{In Python}
\begin{code}
def capital_city(country):
   capital = None
   if country == "France":
      capital = "Paris"
   elif country == "UK":
      capital = "London"
   elif country == "Spain":
      capital = "Madrid"
   return capital
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{In Python}
\begin{code}
capital_dict = { 
  "France": "Paris", 
  "UK":     "London", 
  "Spain":  "Madrid" 
}

def capital_city(country):
   capital = None
   if country in capital_dict:
      capital = capital_dict[country]
   return capital
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{Return values}
When we return a value from a function, we can collect that value into
a variable:
\begin{code}
c = capital_city("UK")
print(c)

d = capital_city("Germany")
print(d) 
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{Return values and None}
Some functions in Python don't return a value. They are written
solely for their side effects (often printing to a screen or writing
to a file)
\begin{code}
def print_hashes(num):
   for i in range(num):
      print('#' * i)
\end{code}

This is still known as a {\em function} in Python, even though it seems
that it doesn't return a value. In fact it does actually return a
value: it returns the value \texttt{None}. 

\bigskip

N.B. Sometimes when we write a function just for its side effects rather than
its return value we might instead choose to return a boolean,
as an indicator of success or failure.
\end{frame}

\begin{frame}[fragile]
\frametitle{Partial functions give a ValueError Exception}
\begin{code}
>>> import math
>>> n = math.sqrt(9)
>>> print(n)
3.0
>>> n = math.sqrt(-9)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: math domain error
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{Parameters}
If I define a function that takes two parameters, then I must call it
with two parameters:
\begin{code}
def perimeter(width, height):
   return (width*2) + (height*2)

print( perimeter(4, 5) )
\end{code}

\end{frame}

\begin{frame}[fragile]
\frametitle{Named parameters}
If we name the parameters when I supply the values then we can put
them in any order. However this is not a good idea, for code readability.
\begin{code}
def perimeter(width, height):
   return (width*2) + (height*2)

print( perimeter(4, 5) )
print( perimeter(width=4, height=5) )
print( perimeter(height=5, width=4) )
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{Named parameters}
However we can give the parameters default values and then the names
and ability to use them in any order becomes more useful.
\begin{code}
def perimeter(width=7, height=6):
   return (width*2) + (height*2)

print( perimeter(4, 5) )  
print( perimeter(width=4) )  
print( perimeter(height=5) ) 
print( perimeter() )  
\end{code}
\end{frame}



\begin{frame}[fragile]
\frametitle{Functions have a type}
Functions have the type 'function'.
\begin{code}
>>> type(perimeter)
<type 'function'>
>>> type(len)
<type 'builtin_function_or_method'>
>>> type(max)
<type 'builtin_function_or_method'>
\end{code}
When we just use the name, e.g. \texttt{perimeter} we are referring
to the function itself. When we add brackets, we are calling the
function instead, e.g.  \texttt{perimeter(3,4)}.
\end{frame}



\begin{frame}[fragile]
\frametitle{Functions as arguments}
We can pass functions as arguments. Here I pass the function \texttt{len}, and
I also pass the function \texttt{first\_char}.
\begin{code}
def is_ok_text( word, f ):
   score = f(word)
   return score < 10

def first_char(word):
   return (ord (word[0]) )

x = is_ok_text("hello", len)
y = is_ok_text("hello", first_char)
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{Functions as arguments}
Suppose we're playing Scrabble. We want to define rules for which
words are acceptable. 
\begin{code}
def tough(word):
   return ( len(word) > 3
            and not word.endswith('s')
            and word[0].upper() != word[0] )

def easy(word):
   return True
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{Functions as arguments}
\begin{code}
def playScrabble(num_players, rules):
   # some code to set up and play
   # at some point we can test a word
   word = get_word_from_player(n)
   if rules(word):
      # play carries on
   else:
      # choose another word

# Which rules are we playing?
playScrabble(4, tough)
\end{code}
\end{frame}


\begin{frame}[fragile]
\frametitle{Lambda functions}
We can also define simple functions using the lambda keyword. 
\begin{code}
number_of_ls = lambda s : return s.count('l')
say_hello = lambda name: return "hello " + name 

print (say_hello("Amanda"))
print (number_of_ls(say_hello("Amanda")))
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{Lambda functions}
Lambda functions are a convenient notation but not necessary. 
These functions are equivalent:
\begin{code}
number_of_ls = lambda s : s.count('l')

def number_of_ls(s):
   return s.count('l')
\end{code}
\begin{code}
say_hello = lambda name: "hello " + name 

def say_hello(name):
   return "hello " + name 
\end{code}
\end{frame}

\begin{frame}[fragile]
\frametitle{Lambda functions}
Lambda functions can only be used for simple, single line functions.

\bigskip

After the colon must be an expression which produces the returned
value.

\bigskip

Lambda functions can take more than one argument:

\begin{code}
perimeter = lambda height,width : width*2 + height*2 
\end{code}
\end{frame}

\begin{frame}
\frametitle{Summary}
\begin{itemize}
\item Functions and relations
\item Return values, None and print
\item Parameters
\item Passing functions
\item Lambda functions
\end{itemize}
\end{frame}

\end{document}
